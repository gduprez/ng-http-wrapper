var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            /**
             * TODO MGA : export an interface too ?
             */
            var ApiConfig = (function () {
                function ApiConfig(coreApiUrl, 
                    //TODO MGA : to inject as generic list of custom headers to pass to $http service ?
                    jwtToken, currentUserRole) {
                    this.coreApiUrl = coreApiUrl;
                    this.jwtToken = jwtToken;
                    this.currentUserRole = currentUserRole;
                }
                return ApiConfig;
            }());
            models.ApiConfig = ApiConfig;
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            /**
             * TODO MGA : this may not need to be a dedicated service, it can also be incorporated into the httpInterceptor. Decide best approach depending on planned use.
             */
            var HttpWrapperService = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                HttpWrapperService.$inject = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                function HttpWrapperService($http, $window, $log, $q, $location, Upload, toaster) {
                    var _this = this;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        //Init config even if not provided
                        config = config || {};
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        if (config.apiEndpoint && (!_this.apiConfig ||
                            !_this.apiConfig.jwtToken ||
                            !_this.apiConfig.currentUserRole)) {
                            _this.$log.error("[InternalError] [" + configFull.method + " / " + url + "] - coreApi call intended without necessary capi credentials. Aborting.");
                            return null;
                        }
                        configFull.headers = config.headers || {};
                        if (!config.apiEndpoint) {
                            configFull.url = _this.buildUrlFromContext(url);
                        }
                        else {
                            //TODO MGA : core api endpoint 'api/' hardcoded, to put in configFull ! should not know that here.
                            configFull.url = _this.apiConfig.coreApiUrl + 'api/' + url;
                            if (_this.apiConfig.jwtToken && _this.apiConfig.currentUserRole) {
                                //TODO MGA: hard coded headers, not good, to inject
                                configFull.headers['OA-UserRole'] = _this.apiConfig.currentUserRole;
                                configFull.headers['Authorization'] = 'Bearer ' + _this.apiConfig.jwtToken;
                            }
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        //TODO MGA: OE specific code, to remove
                        if (_this.$window.preventBlockUI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler
                     * @returns {}
                     */
                    this.success = function (httpPromise) {
                        // JS trick : capture url variable inside closure scope to store it for callback which cannot be called with 2 arguments
                        if (!httpPromise) {
                            _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "] Unexpected $http error, no return promise object could be found.");
                            _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                            return _this.$q.reject(httpPromise); // Reject promise
                        }
                        //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                        //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                        //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                        //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                        //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                        //}
                        //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                        //TODO MGA: get full url of request
                        _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        return httpPromise.data; // return only the data expected for caller
                    };
                    /**
                     * Error handler
                     * @param httpPromise
                     * @returns {}
                     */
                    this.error = function (httpPromise) {
                        // We suppose in case of no response that the srv didn't send any response.
                        // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                        if (!httpPromise || !httpPromise.data) {
                            httpPromise.data = 'Server not responding';
                            httpPromise.status = 503;
                        }
                        var contentType = httpPromise.headers('Content-Type');
                        if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                            var message;
                            //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                            //if (response.data.ModelState) {
                            //    //TODO MGA : handle this when well formatted server-side
                            //} else
                            if (httpPromise.data.Message) {
                                message = httpPromise.data.Message;
                            }
                            else {
                                message = httpPromise.data;
                            }
                            //TODO MGA: handle more response codes gracefully.
                            if (httpPromise.status === 404) {
                                _this.toaster.warning('Not Found', message);
                            }
                            else {
                                _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                            }
                        }
                        else {
                            _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                        }
                        //TODO MGA: get full url of request
                        _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                        // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                        return _this.$q.reject(httpPromise);
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.preventBlockUI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    // init core api config data on ctor
                    //TODO MGA : hard coded path for CorerApiAuthCtrl to inject
                    this.initPromise = this.$http.get(this.buildUrlFromContext('CoreApiAuth/GetCoreApiConfig'))
                        .success(function (coreApiConfig) {
                        _this.apiConfig = coreApiConfig;
                    }).error(function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting httpWrapperService initialization.');
                        return $q.reject(error);
                    });
                }
                //#endregion
                //#region public methods
                HttpWrapperService.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                HttpWrapperService.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                HttpWrapperService.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                HttpWrapperService.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                HttpWrapperService.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IHttpWrapperConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API (initCall)
                        return this.initPromise.then(function () {
                            //TODO MGA : not safe hard cast
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            return _this.Upload.upload(_this.configureHttpCall(HttpMethod.POST, url, config))
                                .then(_this.success, _this.error, config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                .finally(_this.finally);
                        });
                    }
                };
                //TODO MGA : method too specific to OM apps context, may not work outside of it, to adapt for public use ?
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 */
                HttpWrapperService.prototype.buildUrlFromContext = function (urlInput) {
                    // 1 - Url starts with http:// or https:// => return as is.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        return urlInput;
                    }
                    // 2 - Otherwise, try to find correct controller
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, '/'.length) === '/';
                    // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                    var controllerIsPresentRegex = /\w+\/\w+/;
                    var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                    var baseUrl = this.getUrlPath(actionIsOnSameController);
                    return baseUrl + (urlFragmentStartsWithSlash ? urlInput : ('/' + urlInput));
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                HttpWrapperService.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure initPromise resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.initPromise.then(function () {
                        return _this.$http(_this.configureHttpCall(method, url, config))
                            .then(_this.success, _this.error)
                            .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA : make it capable of handling full URLs outside of OE : do not use ?? how to ?
                HttpWrapperService.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlRegex = /(\/\w+\/\(S\(\w+\)\))\/\w+/;
                    var url = this.$window.location.pathname;
                    var baseUrlMatches = baseUrlRegex.exec(url);
                    if (baseUrlMatches.length && baseUrlMatches.length === 2) {
                        var baseUrlWithControllerName = baseUrlMatches[0];
                        var baseUrl = baseUrlMatches[1];
                        if (actionIsOnSameController) {
                            return baseUrlWithControllerName;
                        }
                        else {
                            return baseUrl;
                        }
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                HttpWrapperService.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error("Unable to recognized searched pattern in current url location to retrieve sessionID.");
                        return "";
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error("Unable to find sessionID in searched pattern in current url.");
                        return "";
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error("Too many matches found for the sessionID search in the current url.");
                        return "";
                    }
                    return regexpArray[1];
                };
                return HttpWrapperService;
            }());
            services.HttpWrapperService = HttpWrapperService;
            angular.module('ng.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .service('httpWrapperService', HttpWrapperService);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwaS1jb25maWcubW9kZWwudHMiLCJodHRwLXdyYXBwZXIuc2VydmljZS50cyIsIm5nLWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFVO0FBQVYsQ0FBQSxVQUFVLFNBQU87SUFBQyxJQUFBO0lBQUEsQ0FBQSxVQUFBLE1BQUk7UUFBQyxJQUFBO1FBQUEsQ0FBQSxVQUFBLFFBQU87Ozs7WUFJMUIsSUFBQSxhQUFBLFlBQUE7Z0JBQ0ksU0FBQSxVQUNXOztvQkFFQSxVQUNBLGlCQUF1QjtvQkFIdkIsS0FBQSxhQUFBO29CQUVBLEtBQUEsV0FBQTtvQkFDQSxLQUFBLGtCQUFBOztnQkFFZixPQUFBOztZQVBhLE9BQUEsWUFBUztXQUpILFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QUNBakIsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxVQUFTO1lBZTVCLElBQUs7WUFBTCxDQUFBLFVBQUssWUFBVTtnQkFBRyxXQUFBLFdBQUEsU0FBQSxLQUFBO2dCQUFLLFdBQUEsV0FBQSxVQUFBLEtBQUE7Z0JBQU0sV0FBQSxXQUFBLFNBQUEsS0FBQTtnQkFBSyxXQUFBLFdBQUEsWUFBQSxLQUFBO2VBQTdCLGVBQUEsYUFBVTtZQUEyQjs7OztZQThCMUMsSUFBQSxzQkFBQSxZQUFBOzs7OztnQkFZSSxTQUFBLG1CQUNZLE9BQ0EsU0FDQSxNQUNBLElBQ0EsV0FDQSxRQUNBLFNBQWtDO29CQW5CbEQsSUFBQSxRQUFBO29CQWFnQixLQUFBLFFBQUE7b0JBQ0EsS0FBQSxVQUFBO29CQUNBLEtBQUEsT0FBQTtvQkFDQSxLQUFBLEtBQUE7b0JBQ0EsS0FBQSxZQUFBO29CQUNBLEtBQUEsU0FBQTtvQkFDQSxLQUFBLFVBQUE7Ozs7Ozs7Ozs7b0JBZ0lKLEtB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QkFDMUIsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUVYLElBQUksWUFBWSxTQUFTLEdBQUc7d0JBQ3hCLEtBQUssS0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFHWCxPQUFPLFlBQVk7O2dCQUkzQixPQUFBOztZQW5WYSxTQUFBLHFCQUFrQjtZQXFWL0IsUUFBUSxPQUFPLGtCQUFrQixDQUFDLFdBQVcsYUFBYTtpQkFLckQsUUFBUSxzQkFBc0I7V0F2WWhCLFdBQUEsS0FBQSxhQUFBLEtBQUEsV0FBUTtPQUFiLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBQ21VakIiLCJmaWxlIjoibmctaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSA6IGV4cG9ydCBhbiBpbnRlcmZhY2UgdG9vID9cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEFwaUNvbmZpZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHB1YmxpYyBjb3JlQXBpVXJsOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiB0byBpbmplY3QgYXMgZ2VuZXJpYyBsaXN0IG9mIGN1c3RvbSBoZWFkZXJzIHRvIHBhc3MgdG8gJGh0dHAgc2VydmljZSA/XHJcbiAgICAgICAgICAgIHB1YmxpYyBqd3RUb2tlbjogc3RyaW5nLFxyXG4gICAgICAgICAgICBwdWJsaWMgY3VycmVudFVzZXJSb2xlOiBzdHJpbmdcclxuICAgICAgICApIHsgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5zZXJ2aWNlcyB7XHJcblxyXG4gICAgaW1wb3J0IEFwaUNvbmZpZyA9IGJsdWVza3kuY29yZS5tb2RlbHMuQXBpQ29uZmlnO1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUh0dHBXcmFwcGVyQ29uZmlnIGV4dGVuZHMgbmcuSVJlcXVlc3RTaG9ydGN1dENvbmZpZyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWFpbiBBUEkgZW5kcG9pbnQgdG8gdXNlIGFzIGRlZmF1bHQgb25lIGlmIHVybCBpcyBub3QgZnVsbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhcGlFbmRwb2ludD86IGJvb2xlYW47XHJcbiAgICAgICAgZmlsZT86IEZpbGUsXHJcbiAgICAgICAgdXBsb2FkSW5CYXNlNjRKc29uPzogYm9vbGVhbjtcclxuICAgICAgICB1cGxvYWRQcm9ncmVzcz86ICgpID0+IGFueTtcclxuICAgICAgICBkaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXI/OiBib29sZWFuO1xyXG4gICAgfVxyXG5cclxuICAgIGVudW0gSHR0cE1ldGhvZCB7IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgfTtcclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIElIdHRwV3JhcHBlclNlcnZpY2Uge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgc3J2LXNpZGUgY29uZmlndXJhdGlvbiBvZiBtYWluIEFQSSBwcm92aWRlZCBieSB0aGUgZG9tYWluIGZyb20gd2hpY2ggdGhpcyBzY3JpcHQgd2FzIGxvYWRlZCwgQCB0aGUgdXJsICdDb3JlQXBpQXV0aC9HZXRDb3JlQXBpQ29uZmlnJy5cclxuICAgICAgICAgKiBUT0RPIE1HQSBmaXggaGFyZCBjb2RlZCBwYXRoLlxyXG4gICAgICAgICAqIFRoaXMgY29uZmlndXJhdGlvbiBkYXRhIGlzIGxvYWRlZCB1cG9uIGluaXRpYWxpemF0aW9uIG9mIHRoaXMgc2VydmljZSAodG8gYmUgdXNlZCBhcyBhIHNpbmdsZXRvbiBpbiB0aGUgYXBwKS4gQWxsIG90aGVyIHdlYiBjYWxscyBhcmUgYmxvY2tlZCBhcyBsb25nIGFzIHRoaXMgb25lIGlzIG5vdCBmaW5pc2hlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhcGlDb25maWc6IEFwaUNvbmZpZztcclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogZm9yIGZvbGxvd2luZyBtZXRob2RzLCByZXR1cm4gSVByb21pc2UgYW5kIGFzc3VtZSBhYnN0cmFjdGlvbiBvciBsZXQgYmVsb3cgc2VydmljZXMgaGFuZGxlIElIdHRwUHJvbWlzZXMgP1xyXG5cclxuICAgICAgICBnZXQ8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBkZWxldGU8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBwb3N0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBwdXQ8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIC8vVE9ETyBNR0EgaW1wcm92ZSB0eXBpbmcgd2l0aCBhbmd1bGFyLXVwbG9hZCB0c2QgZXRjXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETyBNR0EgOiB0aGlzIG1heSBub3QgbmVlZCB0byBiZSBhIGRlZGljYXRlZCBzZXJ2aWNlLCBpdCBjYW4gYWxzbyBiZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgaHR0cEludGVyY2VwdG9yLiBEZWNpZGUgYmVzdCBhcHByb2FjaCBkZXBlbmRpbmcgb24gcGxhbm5lZCB1c2UuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBIdHRwV3JhcHBlclNlcnZpY2UgaW1wbGVtZW50cyBJSHR0cFdyYXBwZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIHByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBpbml0UHJvbWlzZTogbmcuSVByb21pc2U8YW55PjtcclxuICAgICAgICBwdWJsaWMgYXBpQ29uZmlnOiBBcGlDb25maWc7XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gY3RvclxyXG5cclxuICAgICAgICAvKiBAbmdJbmplY3QgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICAgICAgcHJpdmF0ZSAkaHR0cDogbmcuSUh0dHBTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICR3aW5kb3c6IG5nLklXaW5kb3dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2c6IG5nLklMb2dTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRxOiBuZy5JUVNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGxvY2F0aW9uOiBuZy5JTG9jYXRpb25TZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIFVwbG9hZDogbmcuYW5ndWxhckZpbGVVcGxvYWQuSVVwbG9hZFNlcnZpY2UsXHJcbiAgICAgICAgICAgIHByaXZhdGUgdG9hc3Rlcjogbmd0b2FzdGVyLklUb2FzdGVyU2VydmljZVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBpbml0IGNvcmUgYXBpIGNvbmZpZyBkYXRhIG9uIGN0b3JcclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGhhcmQgY29kZWQgcGF0aCBmb3IgQ29yZXJBcGlBdXRoQ3RybCB0byBpbmplY3RcclxuICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuJGh0dHAuZ2V0PEFwaUNvbmZpZz4odGhpcy5idWlsZFVybEZyb21Db250ZXh0KCdDb3JlQXBpQXV0aC9HZXRDb3JlQXBpQ29uZmlnJykpXHJcbiAgICAgICAgICAgICAgICAuc3VjY2VzcygoY29yZUFwaUNvbmZpZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpQ29uZmlnID0gY29yZUFwaUNvbmZpZztcclxuICAgICAgICAgICAgICAgIH0pLmVycm9yKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgbWV0aG9kc1xyXG5cclxuICAgICAgICBnZXQ8VD4odXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVsZXRlPFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5ERUxFVEUsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTs7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdXQ8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBVVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBsb2FkPFQ+KHVybDogc3RyaW5nLCBmaWxlOiBGaWxlLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLmZpbGUgPSBmaWxlIHx8IGNvbmZpZy5maWxlOyAvL1RPRE8gTUdBIDogZG8gbm90IGV4cG9zZSBmaWxlIGluIElIdHRwV3JhcHBlckNvbmZpZyA/XHJcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVwbG9hZEluQmFzZTY0SnNvbikge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHRoaXMgZGVsYXlzIG5leHQgY2FsbCBhbmQgdXBsb2FkIGlzIG5vdCBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgaXMgZmluaXNoZWQsIGV2ZW4gaWYgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkID8/P1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLmJhc2U2NERhdGFVcmwoZmlsZSkudGhlbigoZmlsZUJhc2U2NFVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQtY29kZWQga2V5IHRvIGZldGNoIGJhc2U2NCBlbmNvZGluZywgdG8gcGFyYW1ldHJpemUgd2l0aCBzZXJ2ZXItc2lkZSAhXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUJhc2U2NFVybCA9IGZpbGVCYXNlNjRVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWwgcG9zdCBpbiBjYXNlIG9mIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG5vdCBzYWZlIGhhcmQgY2FzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBiZWhhdmlvciBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuYWpheCwgbm90IERSWSwgdG8gaW1wcm92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC51cGxvYWQ8VD4oPG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklGaWxlVXBsb2FkQ29uZmlnRmlsZT50aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLnN1Y2Nlc3MsIHRoaXMuZXJyb3IsIGNvbmZpZy51cGxvYWRQcm9ncmVzcykgLy9UT0RPIE1HQSA6IHVwbG9hZFByb2dyZXNzIGNhbGxiYWNrIG9rID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE8gTUdBIDogbWV0aG9kIHRvbyBzcGVjaWZpYyB0byBPTSBhcHBzIGNvbnRleHQsIG1heSBub3Qgd29yayBvdXRzaWRlIG9mIGl0LCB0byBhZGFwdCBmb3IgcHVibGljIHVzZSA/XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZXMgdG8gcGFyc2UgdGhlIGlucHV0IHVybCA6XHJcbiAgICAgICAgICogSWYgaXQgc2VlbXMgdG8gYmUgYSBmdWxsIFVSTCwgdGhlbiByZXR1cm4gYXMgaXMgKGNvbnNpZGVycyBpdCBleHRlcm5hbCBVcmwpIFxyXG4gICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybCBcclxuICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMuXHJcbiAgICAgICAgICAgIGlmICh1cmxJbnB1dC5zbGljZSgwLCAnaHR0cDovLycubGVuZ3RoKSA9PT0gJ2h0dHA6Ly8nIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJbnB1dC5zbGljZSgwLCAnaHR0cHM6Ly8nLmxlbmd0aCkgPT09ICdodHRwczovLycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMiAtIE90aGVyd2lzZSwgdHJ5IHRvIGZpbmQgY29ycmVjdCBjb250cm9sbGVyXHJcblxyXG4gICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcclxuICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgJy8nLmxlbmd0aCkgPT09ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgKHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID8gdXJsSW5wdXQgOiAoJy8nICsgdXJsSW5wdXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kLlxyXG4gICAgICAgICAqIE1haW4gY2FsbGVyIHRoYXQgYWxsIHdyYXBwZXIgY2FsbHMgKGdldCwgZGVsZXRlLCBwb3N0LCBwdXQpIG11c3QgdXNlIHRvIHNoYXJlIGNvbW1vbiBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBhamF4PFQ+KG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZykge1xyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFrZSBzdXJlIGluaXRQcm9taXNlIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8VD4odGhpcy5jb25maWd1cmVIdHRwQ2FsbChtZXRob2QsIHVybCwgY29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLnN1Y2Nlc3MsIHRoaXMuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFByZXBhcmVzIGEge0BsaW5rIG5nIyRodHRwI2NvbmZpZyBjb25maWd9IG9iamVjdCBmb3IgJGh0dHAgY2FsbC5cclxuICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxyXG4gICAgICAgICogIC0gQWpheCBjYWxsc1xyXG4gICAgICAgICogIC0gQXV0aG9yaXphdGlvbiB0b2tlblxyXG4gICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS4gICBcclxuICAgICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgICAgKiBAcmV0dXJucyB7bmcuJGh0dHAuY29uZmlnfSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcmVhZHkgdG8gYmUgaW5qZWN0ZWQgaW50byBhICRodHRwIGNhbGwuIFxyXG4gICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBjb25maWd1cmVIdHRwQ2FsbCA9IChtZXRob2Q6IEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUmVxdWVzdENvbmZpZyA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVVJMICYgTUVUSE9EIHBhcmFtZXRlcnMgYXJlIG5lY2Vzc2FyeSBmb3IgaHR0cFdyYXBwZXIgY2FsbHMuIEFib3J0aW5nLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vSW5pdCBjb25maWcgZXZlbiBpZiBub3QgcHJvdmlkZWRcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjYXN0IGlzIG5vdCBzYWZlLCB3ZSBtYXkgZm9yZ2V0IHRvIHNldCB1cmwgJiBtZXRob2QgcGFyYW1ldGVycy4gVE9GSVguXHJcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2V0IGFsbCBub24tZmlsdGVyZWQgcGFyYW1ldGVycyAmIGtlZXAgdGhlbSBmb3IgdGhpcyBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICB2YXIgY29uZmlnRnVsbCA9IDxuZy5JUmVxdWVzdENvbmZpZz5jb25maWc7XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzdXBwb3J0IG1hcHBpbmcgYmV0d2VlbiB1cGxvYWQgJiBwb3N0IGhlcmUgP1xyXG4gICAgICAgICAgICBjb25maWdGdWxsLm1ldGhvZCA9IEh0dHBNZXRob2RbbWV0aG9kXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuYXBpRW5kcG9pbnQgJiYgKCF0aGlzLmFwaUNvbmZpZyB8fFxyXG4gICAgICAgICAgICAgICAgIXRoaXMuYXBpQ29uZmlnLmp3dFRva2VuIHx8XHJcbiAgICAgICAgICAgICAgICAhdGhpcy5hcGlDb25maWcuY3VycmVudFVzZXJSb2xlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbSW50ZXJuYWxFcnJvcl0gWyR7Y29uZmlnRnVsbC5tZXRob2R9IC8gJHt1cmx9XSAtIGNvcmVBcGkgY2FsbCBpbnRlbmRlZCB3aXRob3V0IG5lY2Vzc2FyeSBjYXBpIGNyZWRlbnRpYWxzLiBBYm9ydGluZy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmFwaUVuZHBvaW50KSB7IC8vIGlmIG5vdCBzZXQsIGV2YWx1YXRlcyB0byBmYWxzZVxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSB0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQodXJsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBjb3JlIGFwaSBlbmRwb2ludCAnYXBpLycgaGFyZGNvZGVkLCB0byBwdXQgaW4gY29uZmlnRnVsbCAhIHNob3VsZCBub3Qga25vdyB0aGF0IGhlcmUuXHJcbiAgICAgICAgICAgICAgICBjb25maWdGdWxsLnVybCA9IHRoaXMuYXBpQ29uZmlnLmNvcmVBcGlVcmwgKyAnYXBpLycgKyB1cmw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ29uZmlnLmp3dFRva2VuICYmIHRoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY29kZWQgaGVhZGVycywgbm90IGdvb2QsIHRvIGluamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snT0EtVXNlclJvbGUnXSA9IHRoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIHRoaXMuYXBpQ29uZmlnLmp3dFRva2VuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlWG1sSHR0cFJlcXVlc3RIZWFkZXIpIC8vIGlmIG5vdCBzZXQsIGV2YWx1YXRlcyB0byBmYWxzZVxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Ugc3BlY2lmaWMgY29kZSwgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLnByZXZlbnRCbG9ja1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnRnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1Y2Nlc3MgaGFuZGxlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHt9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgc3VjY2VzcyA9IDxUPihodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pOiBUIHwgbmcuSVByb21pc2U8YW55PiA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBKUyB0cmljayA6IGNhcHR1cmUgdXJsIHZhcmlhYmxlIGluc2lkZSBjbG9zdXJlIHNjb3BlIHRvIHN0b3JlIGl0IGZvciBjYWxsYmFjayB3aGljaCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggMiBhcmd1bWVudHNcclxuICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKGBbSFRUUCAke2h0dHBQcm9taXNlLmNvbmZpZy5tZXRob2R9XSBbJHtodHRwUHJvbWlzZS5jb25maWcudXJsfV0gVW5leHBlY3RlZCAkaHR0cCBlcnJvciwgbm8gcmV0dXJuIHByb21pc2Ugb2JqZWN0IGNvdWxkIGJlIGZvdW5kLmApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLmVycm9yKCdVbmV4cGVjdGVkIGJlaGF2aW9yJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTsgLy8gUmVqZWN0IHByb21pc2VcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHdoZW4gQVBJIGlzIGZpeGVkLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTc0Njg5NC93aGF0LWlzLXRoZS1wcm9wZXItcmVzdC1yZXNwb25zZS1jb2RlLWZvci1hLXZhbGlkLXJlcXVlc3QtYnV0LWFuLWVtcHR5LWRhdGFcclxuICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xyXG4gICAgICAgICAgICAvLyAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBleHBlY3RlZCByZXNwb25zZSBkYXRhIGJ1dCBub25lIGZvdW5kLicpO1xyXG4gICAgICAgICAgICAvLyAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnVW5leHBlY3RlZCByZXNwb25zZScsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcclxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBzYW1lIGJlaGF2aW9yIGFsc28gb24gYSBHRVQgcmVxdWVzdCA/IGlmIHJlcXVlc3QgaXMgR0VUIGFuZCByZXNwb25zZSBpcyAyMDAgd2l0aCBubyBkYXRhLCByZXR1cm4gZXJyb3IgPyAocGFzcyBpbiBwYXJhbWV0ZXIgcmVxdWVzdCBjb250ZXh0IHRvIGxvZyB0aGlzIGVycm9yKS5cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgIHRoaXMuJGxvZy5kZWJ1ZyhgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7IC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVycm9yIGhhbmRsZXJcclxuICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2UgXHJcbiAgICAgICAgICogQHJldHVybnMge30gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBlcnJvciA9IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55Pik6IG5nLklQcm9taXNlPG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4+ID0+IHsgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cclxuICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXHJcbiAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgICAgLy99IGVsc2VcclxuICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgbW9yZSByZXNwb25zZSBjb2RlcyBncmFjZWZ1bGx5LlxyXG4gICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1NlcnZlciByZXNwb25zZSBlcnJvcicsIG1lc3NhZ2UgKyAnXFxuIFN0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlY292ZXIgZnJvbSBlcnJvciwgc28gd2UgcHJvcGFnYXRlIGl0IDogYmVsb3cgaGFuZGxlcnMgaGF2ZSB0aGUgY2hvaWNlIG9mIHJlYWRpbmcgdGhlIGVycm9yIHdpdGggYW4gZXJyb3IgaGFuZGxlciBvciBub3QuIFNlZSAkcSBwcm9taXNlcyBiZWhhdmlvciBoZXJlIDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xXHJcbiAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYWpheCBjYWxsLCByZWdhcmRsZXNzIG9mIGl0J3Mgc3VjY2VzcyBvciBmYWlsdXJlLlxyXG4gICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgZmluYWxseSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Utc3BlY2lmaWMgY29kZVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxyXG4gICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIGl0IGNhcGFibGUgb2YgaGFuZGxpbmcgZnVsbCBVUkxzIG91dHNpZGUgb2YgT0UgOiBkbyBub3QgdXNlID8/IGhvdyB0byA/XHJcbiAgICAgICAgcHJpdmF0ZSBnZXRVcmxQYXRoKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcikge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdysvO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybE1hdGNoZXMgPSBiYXNlVXJsUmVnZXguZXhlYyh1cmwpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhc2VVcmxNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBiYXNlVXJsTWF0Y2hlc1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE8gTUdBOiBPTS1zcGVjaWZpYyBBU1AgTVZDIGNvZGUsIG5vdCB1c2VkIEFUTSwgdG8gcmVtb3ZlXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRDdXJyZW50U2Vzc2lvbklEKCkge1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxyXG4gICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIlVuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIlVuYWJsZSB0byBmaW5kIHNlc3Npb25JRCBpbiBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoXCJUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgfVxyXG5cclxuICAgIGFuZ3VsYXIubW9kdWxlKCduZy5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXHJcbiAgICAgICAgLy8gZG9uZSBpbiBjb25maWd1cmVIdHRwQ2FsbCBtZXRob2QuXHJcbiAgICAgICAgLy8uY29uZmlnKFsnJGh0dHBQcm92aWRlcicsICgkaHR0cFByb3ZpZGVyOiBuZy5JSHR0cFByb3ZpZGVyKSA9PiB7XHJcbiAgICAgICAgLy8gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuICAgICAgICAvL31dKVxyXG4gICAgICAgIC5zZXJ2aWNlKCdodHRwV3JhcHBlclNlcnZpY2UnLCBIdHRwV3JhcHBlclNlcnZpY2UpO1xyXG59IiwidmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIG1vZGVscztcbiAgICAgICAgKGZ1bmN0aW9uIChtb2RlbHMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETyBNR0EgOiBleHBvcnQgYW4gaW50ZXJmYWNlIHRvbyA/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBBcGlDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEFwaUNvbmZpZyhjb3JlQXBpVXJsLCBcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IHRvIGluamVjdCBhcyBnZW5lcmljIGxpc3Qgb2YgY3VzdG9tIGhlYWRlcnMgdG8gcGFzcyB0byAkaHR0cCBzZXJ2aWNlID9cbiAgICAgICAgICAgICAgICAgICAgand0VG9rZW4sIGN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcmVBcGlVcmwgPSBjb3JlQXBpVXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmp3dFRva2VuID0gand0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFVzZXJSb2xlID0gY3VycmVudFVzZXJSb2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQXBpQ29uZmlnO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIG1vZGVscy5BcGlDb25maWcgPSBBcGlDb25maWc7XG4gICAgICAgIH0pKG1vZGVscyA9IGNvcmUubW9kZWxzIHx8IChjb3JlLm1vZGVscyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZXM7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZXMpIHtcbiAgICAgICAgICAgIHZhciBIdHRwTWV0aG9kO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChIdHRwTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiR0VUXCJdID0gMF0gPSBcIkdFVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBPU1RcIl0gPSAxXSA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBVVFwiXSA9IDJdID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJERUxFVEVcIl0gPSAzXSA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICB9KShIdHRwTWV0aG9kIHx8IChIdHRwTWV0aG9kID0ge30pKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETyBNR0EgOiB0aGlzIG1heSBub3QgbmVlZCB0byBiZSBhIGRlZGljYXRlZCBzZXJ2aWNlLCBpdCBjYW4gYWxzbyBiZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgaHR0cEludGVyY2VwdG9yLiBEZWNpZGUgYmVzdCBhcHByb2FjaCBkZXBlbmRpbmcgb24gcGxhbm5lZCB1c2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBIdHRwV3JhcHBlclNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBjdG9yXG4gICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSHR0cFdyYXBwZXJTZXJ2aWNlKCRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHR0cCA9ICRodHRwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aW5kb3cgPSAkd2luZG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cgPSAkbG9nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRxID0gJHE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlVwbG9hZCA9IFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyID0gdG9hc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogUHJlcGFyZXMgYSB7QGxpbmsgbmcjJGh0dHAjY29uZmlnIGNvbmZpZ30gb2JqZWN0IGZvciAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAqICAtIEFqYXggY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgKiAgLSBBdXRob3JpemF0aW9uIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS5cbiAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtuZy4kaHR0cC5jb25maWd9IHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCByZWFkeSB0byBiZSBpbmplY3RlZCBpbnRvIGEgJGh0dHAgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVIdHRwQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVUkwgJiBNRVRIT0QgcGFyYW1ldGVycyBhcmUgbmVjZXNzYXJ5IGZvciBodHRwV3JhcHBlciBjYWxscy4gQWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0luaXQgY29uZmlnIGV2ZW4gaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNhc3QgaXMgbm90IHNhZmUsIHdlIG1heSBmb3JnZXQgdG8gc2V0IHVybCAmIG1ldGhvZCBwYXJhbWV0ZXJzLiBUT0ZJWC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2V0IGFsbCBub24tZmlsdGVyZWQgcGFyYW1ldGVycyAmIGtlZXAgdGhlbSBmb3IgdGhpcyBuZXcgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzdXBwb3J0IG1hcHBpbmcgYmV0d2VlbiB1cGxvYWQgJiBwb3N0IGhlcmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFwaUVuZHBvaW50ICYmICghX3RoaXMuYXBpQ29uZmlnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5hcGlDb25maWcuY3VycmVudFVzZXJSb2xlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSW50ZXJuYWxFcnJvcl0gW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gY29yZUFwaSBjYWxsIGludGVuZGVkIHdpdGhvdXQgbmVjZXNzYXJ5IGNhcGkgY3JlZGVudGlhbHMuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuYXBpRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLnVybCA9IF90aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBjb3JlIGFwaSBlbmRwb2ludCAnYXBpLycgaGFyZGNvZGVkLCB0byBwdXQgaW4gY29uZmlnRnVsbCAhIHNob3VsZCBub3Qga25vdyB0aGF0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSBfdGhpcy5hcGlDb25maWcuY29yZUFwaVVybCArICdhcGkvJyArIHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXBpQ29uZmlnLmp3dFRva2VuICYmIF90aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXJzLCBub3QgZ29vZCwgdG8gaW5qZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snT0EtVXNlclJvbGUnXSA9IF90aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgX3RoaXMuYXBpQ29uZmlnLmp3dFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRSBzcGVjaWZpYyBjb2RlLCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWdGdWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpTIHRyaWNrIDogY2FwdHVyZSB1cmwgdmFyaWFibGUgaW5zaWRlIGNsb3N1cmUgc2NvcGUgdG8gc3RvcmUgaXQgZm9yIGNhbGxiYWNrIHdoaWNoIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCAyIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXSBVbmV4cGVjdGVkICRodHRwIGVycm9yLCBubyByZXR1cm4gcHJvbWlzZSBvYmplY3QgY291bGQgYmUgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7IC8vIFJlamVjdCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgd2hlbiBBUEkgaXMgZml4ZWQuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExNzQ2ODk0L3doYXQtaXMtdGhlLXByb3Blci1yZXN0LXJlc3BvbnNlLWNvZGUtZm9yLWEtdmFsaWQtcmVxdWVzdC1idXQtYW4tZW1wdHktZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoKHByb21pc2VDYWxsYmFjay5kYXRhID09PSBudWxsIHx8IHByb21pc2VDYWxsYmFjay5kYXRhID09PSB1bmRlZmluZWQpICYmIHByb21pc2VDYWxsYmFjay5zdGF0dXMgIT09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRoaXMudG9hc3Rlci53YXJuaW5nKCdVbmV4cGVjdGVkIHJlc3BvbnNlJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuJHEucmVqZWN0KHByb21pc2VDYWxsYmFjayk7IC8vIFJlamVjdCBwcm9taXNlIGlmIG5vdCB3ZWxsLWZvcm1lZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHNhbWUgYmVoYXZpb3IgYWxzbyBvbiBhIEdFVCByZXF1ZXN0ID8gaWYgcmVxdWVzdCBpcyBHRVQgYW5kIHJlc3BvbnNlIGlzIDIwMCB3aXRoIG5vIGRhdGEsIHJldHVybiBlcnJvciA/IChwYXNzIGluIHBhcmFtZXRlciByZXF1ZXN0IGNvbnRleHQgdG8gbG9nIHRoaXMgZXJyb3IpLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZGVidWcoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFByb21pc2UuZGF0YTsgLy8gcmV0dXJuIG9ubHkgdGhlIGRhdGEgZXhwZWN0ZWQgZm9yIGNhbGxlclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge31cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoaHR0cFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHN1cHBvc2UgaW4gY2FzZSBvZiBubyByZXNwb25zZSB0aGF0IHRoZSBzcnYgZGlkbid0IHNlbmQgYW55IHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlIHx8ICFodHRwUHJvbWlzZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2UuZGF0YSA9ICdTZXJ2ZXIgbm90IHJlc3BvbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGh0dHBQcm9taXNlLmhlYWRlcnMoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCd0ZXh0L3BsYWluJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgZXJyb3IgaGFuZGxpbmcgbW9yZSBnZW5lcmljYWxseSBiYXNlZCBvbiBpbnB1dCBlcnJvciBtZXNzYWdlIGNvbnRyYWN0IGluc3RlYWQgb2YgZXhwZWN0aW5nIHNwZWNpZmljIGVycm9yIHN0cmN0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHJlc3BvbnNlLmRhdGEuTW9kZWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC8vVE9ETyBNR0EgOiBoYW5kbGUgdGhpcyB3aGVuIHdlbGwgZm9ybWF0dGVkIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIG1vcmUgcmVzcG9uc2UgY29kZXMgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci53YXJuaW5nKCdOb3QgRm91bmQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ1NlcnZlciByZXNwb25zZSBlcnJvcicsIG1lc3NhZ2UgKyAnXFxuIFN0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJ1N0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltIVFRQIFwiICsgaHR0cFByb21pc2UuY29uZmlnLm1ldGhvZCArIFwiXSBbXCIgKyBodHRwUHJvbWlzZS5jb25maWcudXJsICsgXCJdXCIsIGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHJlY292ZXIgZnJvbSBlcnJvciwgc28gd2UgcHJvcGFnYXRlIGl0IDogYmVsb3cgaGFuZGxlcnMgaGF2ZSB0aGUgY2hvaWNlIG9mIHJlYWRpbmcgdGhlIGVycm9yIHdpdGggYW4gZXJyb3IgaGFuZGxlciBvciBub3QuIFNlZSAkcSBwcm9taXNlcyBiZWhhdmlvciBoZXJlIDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGRlc2lyZWQgc28gdGhhdCB3ZSBzaG93IGVycm9yIGluc2lkZSBzcGVjaWZpYyBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBtb2RhbHMgYXQgc3BlY2lmaWMgcGxhY2VzIGluIHRoZSBhcHAsIG90aGVyd2lzZSBzaG93IGEgZ2xvYmFsIGFsZXJ0IG1lc3NhZ2UsIG9yIGV2ZW4gZG8gbm90IHNob3cgYW55dGhpbmcgaWYgbm90IG5lY2Vzc2FyeSAoZG8gbm90IGFkIGFuIGVycm9yIGhhbmRsZXIgaW4gYmVsb3cgaGFuZGxlcnMgb2YgdGhpcyBwcm9taXNlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kcS5yZWplY3QoaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYWpheCBjYWxsLCByZWdhcmRsZXNzIG9mIGl0J3Mgc3VjY2VzcyBvciBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FLXNwZWNpZmljIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXQgY29yZSBhcGkgY29uZmlnIGRhdGEgb24gY3RvclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogaGFyZCBjb2RlZCBwYXRoIGZvciBDb3JlckFwaUF1dGhDdHJsIHRvIGluamVjdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy4kaHR0cC5nZXQodGhpcy5idWlsZFVybEZyb21Db250ZXh0KCdDb3JlQXBpQXV0aC9HZXRDb3JlQXBpQ29uZmlnJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoY29yZUFwaUNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXBpQ29uZmlnID0gY29yZUFwaUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgQVBJIGNvbmZpZy4gQWJvcnRpbmcgaHR0cFdyYXBwZXJTZXJ2aWNlIGluaXRpYWxpemF0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUFVULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh1cmwsIGZpbGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUgJiYgKCFjb25maWcgfHwgIWNvbmZpZy5maWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdDYW5ub3Qgc3RhcnQgdXBsb2FkIHdpdGggbnVsbCB7ZmlsZX0gcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZmlsZSA9IGZpbGUgfHwgY29uZmlnLmZpbGU7IC8vVE9ETyBNR0EgOiBkbyBub3QgZXhwb3NlIGZpbGUgaW4gSUh0dHBXcmFwcGVyQ29uZmlnID9cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oZnVuY3Rpb24gKGZpbGVCYXNlNjRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVGb3JtRGF0YU5hbWUgPSAnZmlsZSc7IC8vIGZpbGUgZm9ybURhdGEgbmFtZSAoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKSwgc2VydmVyIHNpZGUgcmVxdWVzdCBmb3JtIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJIChpbml0Q2FsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBub3Qgc2FmZSBoYXJkIGNhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuVXBsb2FkLnVwbG9hZChfdGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMuc3VjY2VzcywgX3RoaXMuZXJyb3IsIGNvbmZpZy51cGxvYWRQcm9ncmVzcykgLy9UT0RPIE1HQSA6IHVwbG9hZFByb2dyZXNzIGNhbGxiYWNrIG9rID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ldGhvZCB0b28gc3BlY2lmaWMgdG8gT00gYXBwcyBjb250ZXh0LCBtYXkgbm90IHdvcmsgb3V0c2lkZSBvZiBpdCwgdG8gYWRhcHQgZm9yIHB1YmxpYyB1c2UgP1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxuICAgICAgICAgICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKVxuICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuYnVpbGRVcmxGcm9tQ29udGV4dCA9IGZ1bmN0aW9uICh1cmxJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAxIC0gVXJsIHN0YXJ0cyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gPT4gcmV0dXJuIGFzIGlzLlxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHA6Ly8nLmxlbmd0aCkgPT09ICdodHRwOi8vJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHBzOi8vJy5sZW5ndGgpID09PSAnaHR0cHM6Ly8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gMiAtIE90aGVyd2lzZSwgdHJ5IHRvIGZpbmQgY29ycmVjdCBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gdXNlZCB0byB0cnkgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgZnVsbCB1cmwgKGFkZCAvIG9yIG5vdCBiZWZvcmUgdGhlIHVybCBmcmFnbWVudCBkZXBlbmRpbmcgb24gaWYgZm91bmQgb3Igbm90KVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPSB1cmxJbnB1dC5zbGljZSgwLCAnLycubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWdleCB0cnlpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbnB1dCBmcmFnbWVudCBjb250YWlucyBhIC8gYmV0d2VlbiB0d28gY2hhcmFjdGVyIHN1aXRlcyA9PiBjb250cm9sbGVyIGdpdmVuIGFzIGlucHV0LCBvdGhlcndpc2UsIGFjdGlvbiBvbiBzYW1lIGNvbnRyb2xsZXIgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleCA9IC9cXHcrXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybCA9IHRoaXMuZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICh1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA/IHVybElucHV0IDogKCcvJyArIHVybElucHV0KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXRpbGl0eSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICogTWFpbiBjYWxsZXIgdGhhdCBhbGwgd3JhcHBlciBjYWxscyAoZ2V0LCBkZWxldGUsIHBvc3QsIHB1dCkgbXVzdCB1c2UgdG8gc2hhcmUgY29tbW9uIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFrZSBzdXJlIGluaXRQcm9taXNlIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKG1ldGhvZCwgdXJsLCBjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLnN1Y2Nlc3MsIF90aGlzLmVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWtlIGl0IGNhcGFibGUgb2YgaGFuZGxpbmcgZnVsbCBVUkxzIG91dHNpZGUgb2YgT0UgOiBkbyBub3QgdXNlID8/IGhvdyB0byA/XG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXRVcmxQYXRoID0gZnVuY3Rpb24gKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFJlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLiR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsTWF0Y2hlcyA9IGJhc2VVcmxSZWdleC5leGVjKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVXJsTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybE1hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBiYXNlVXJsTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRTZXNzaW9uSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleHBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKFwiVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKFwiVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihcIlRvbyBtYW55IG1hdGNoZXMgZm91bmQgZm9yIHRoZSBzZXNzaW9uSUQgc2VhcmNoIGluIHRoZSBjdXJyZW50IHVybC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSHR0cFdyYXBwZXJTZXJ2aWNlO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHNlcnZpY2VzLkh0dHBXcmFwcGVyU2VydmljZSA9IEh0dHBXcmFwcGVyU2VydmljZTtcbiAgICAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCduZy5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXG4gICAgICAgICAgICAgICAgLnNlcnZpY2UoJ2h0dHBXcmFwcGVyU2VydmljZScsIEh0dHBXcmFwcGVyU2VydmljZSk7XG4gICAgICAgIH0pKHNlcnZpY2VzID0gY29yZS5zZXJ2aWNlcyB8fCAoY29yZS5zZXJ2aWNlcyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
